# Problem

给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色
一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边
请你返回给定图中有效路径里面的 最大颜色值 aj->bj。如果图中含有环，请返回 -1 。
路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。
即图有多个路径到"叶子"节点，找出路径中含有最多次数的颜色节点，返回该次数

输入：colors = "abaca", edges = `[[0,1],[0,2],[2,3],[3,4]]`
输出：3

输入：colors = "a", edges = `[[0,0]]`
输出：-1

# Clarify

# Think out loud

1. 不确定该图是否有环，需要判断
   1.1 将edges转换为二维邻接表， x -> nexts
2. 需要遍历的时候需要有路径节点，且路径遍历时，需要记录当前path上的最多次数的节点

   2.1 有多个颜色，怎么确定出现次数最多的颜色, <del>在path比较，用maxColor</del>
   2.2 colorCount: id[]: colorCount[id]++;
   2.3 有没有可能，用一个变量maxColor 来代替colorCount数组呢？

   ===>
   2.4

   ```text
    多种颜色不知道怎么处理，很简单，每次只求一种颜色即可，
    那么有颜色的数值为1，无颜色的数值为0即可
   ```

3. <del>将多个path上颜色最多的次数，再取Max, 得到图最大颜色值</del>
   ===>
   3.1

   ```text
    每次只求一种颜色，就得到所有路径中该颜色的最大颜色值。
    然后将所有颜色的最大颜色值取最大
   ```

**值传递角度思考，递推三要素**：

<del>

- 值传递1：path

  - 状态：path, 表示从root-end的经过路径 path: number[]
  - 递推公式：
  - 搜索顺序：

- 值传递2：maxColor

  - 状态：表示该路径下的maxColor
  - 递推公式：maxColor = max(colors[])
  - 搜索顺序：

</del>

- 状态1：用于环判断 -> 出队个数

  - 状态：出队的节点个数 outCount
  - 递推公式：每次出队时 outCount++
  - 搜索顺序：先序\*访问 -> BFS

- 状态2：最长路径

  - 状态：dp[cur]表示DAG图上起点到终点的全部路径
    - 边界状态: 入度为0的点
    - 目标状态: 搜索到哪里就是哪里
  - 递推公式：
    - dp[cur] = Max(dp[cur], dp[pre] + (colors[cur] === color ? 1 : 0))
  - 搜索顺序：先序\*邻接 -> BFS

# Solution
