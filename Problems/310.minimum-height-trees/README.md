题目中给定的含有 n 个节点的树，可以推出含有以下特征：

- 任意两个节点之间有且仅有一条路径；
- 树中的共有 n−1 条不同的边；
- 叶子节点的度为 1，非叶子节点的度至少为 2；
- 树的高度由根节点到叶子节点的最大距离决定。

方法1:

- 最直接的解法是，枚举以每个节点为根构成的树，然后求出该树的高度，所有树的最小高度即为答案，需要的时间复杂度为 O(n^2)
- 挨个节点遍历bfs，统计下每个节点的高度，然后用map存储起来，后面查询这个高度的集合里最小的就可以了

方法2：拓扑排序思想

- 越是靠里面的节点越有可能是最小高度树。
- 先找到**所有出度为1**的节点，然后把所有出度为1的节点进队列，然后不断地bfs，最后找到的就是**两边同时向中间靠近的节点**，那么这个中间节点就相当于把整个距离二分了，那么它当然就是到两边距离最小的点啦，也就是到其他叶子节点最近的节点了

```
  时空复杂度分析：n是节点个数

  - 空间复杂度：O(n)
    - 构建图的空间:
      - 由于题目给定的图中**任何两个顶点都只有一条路径连接**，因此图中边的数目刚好等于 n−1，
      - 用邻接表构造图所需的空间刚好为 O(n + 2(n-1))
    - BFS队列
      - 在最坏的情况下，队列中可能需要存储所有的节点，所以空间复杂度为O(N)

  - 时间复杂度：O(n)
    - 构建图：遍历所有的边，时间复杂度为O(E)，其中E是边的数量。
    - BFS: 每个节点最多会被访问两次（一次是被放入队列，一次是从队列中取出），所以时间复杂度为O(N)，其中N是节点的数量

```
