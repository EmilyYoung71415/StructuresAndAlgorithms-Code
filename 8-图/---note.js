/**
 * 图的存储方式   邻接表、邻接矩阵
 * 图的遍历     宽度优先    广度优先
 * 图的常见算法   拓扑排序、kruskal算法、prim、Dijkstra算法 
 * 
 * @func 图存储
 * 图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。
 * 任何二元关系都可以用图来表示
 * 图应用：社交网络、道路、航班、通信状态
 * 
 * Graph:
 *      V:一组顶点、
 *      E：一组边，连接V中顶点
 * 邻接矩阵：
 *      不是强连通的图如果用邻接矩阵表示，会有很多0，即浪费存储空间、
 *      图中顶点的数量可能会变，二维数组不灵活
 * 
 * 邻接表：
 *      更灵活
 *      我们可以用列表（数组）、链表，甚至是 散列表或是字典来表示相邻顶点列表
 * 
 * 两者各有侧重，如:要找出顶点v和w是否相邻，使用邻接矩阵会比较快）。
 * 
 * 还有： 关联矩阵
 *      在关联矩阵中，矩阵的行表示顶点，列表示边
 *      如果顶点v是边e的入射点，则array[v][e] === 1；
 *      关联矩阵通常用于边的数量比顶点多的情况下，以节省空间和内存 
 * @func 图遍历
 * 图遍历：
 *      深度优先Breadth-First Search，BFS
 *      广度优先Depth-First Search，DFS
 * 
 * 图遍历作用：
 *      寻找特定的顶点或寻找两个顶点之间的路径，
 *      检查图是否连通，
 *      检查图是否含有环
 * 广度优先搜索算法和深度优先搜索算法基本思想差不多，区别在于待访问顶点 列表的数据结构
 *      深度：栈
 *      广度：队列，最先入队
 *      为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。
    
    广度优先搜索：
        先宽后深、
        从源节点开始依次按照宽度进队列(先访问但不探查)
        同时准备set存放已经探查输出过的节点(避免重复入列)

        探查节点时，先弹出，每弹出一个节点，就把该节点所有没有进过队列的邻接点放入队列
        直至队列变空 

    ===> BFS 使用例子：
        使用BFS寻找最短路径：给定一个图G和源顶点v，找出对每个顶点u，u和v之间最短路径的距离
            ===》 因为BFS 优先访问所有与其距离为1的顶点，接着距离为2.。
        进阶：如果要计算加权图的最短路径
            ===》 Dijkstra：单源最短路径问题
                  Bellman-Ford：边权值为负的单源最短路径问题
                  Floyd-Warshall:求所有顶点对间的最短路径

    深度优先：DFS
        先深度(访问一个节点到尽头后)再调转扩展宽度
        栈实现 + set防止二次遍历
    ===>  使用例子：
        发现&探索时间
        拓扑排序：当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序
    @func 图算法

    @desc 最短路径算法：
            Dijkstra\Floyd-Warshall
    @desc 最小生成树
            Prim\Kruskal算法 
 */