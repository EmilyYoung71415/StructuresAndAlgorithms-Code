/*****
 * 回溯的基本思想：试图产生所有可能的解决方案，但每次生成解决方案测试如果它满足所有条件，那么只有继续生成后续解决方案。
 * 否则回溯并继续寻找不同路径的解决方案。
 * 
 * 类似于枚举，枚举时所有情况的形成过程是一个逐渐扩大的树
 * 复杂度是呈指数级增长。
 * 回溯基于枚举的优化在于：每次深入到下一层时，会检查当前分支是否满足约束条件，
 * 如果满足，则继续深入。不满足则回溯到他的父节点，继续下一个选择
 * 
 * 
 * 
 * 回溯适用的先决条件：
 *    问题满足 多米诺性质 
 *       P(x1,x2,x3,....,xk+1) ——> P(x1,x2,...,xk) 
 *       k+1维向量满足，那么k维向量肯定也满足
 *    逆否：如果k不满足，那么k+1维肯定也不满足
 * 适用于：求解搜索问题 和 优化问题
 * 
 * 算法设计步骤：
 * 1、向量与每个分量的取值范围
 * 2、在当前层中，确定xk的取值集合 Sk (有可能取值范围会随着深入不断缩小)
 * 3、确定节点儿子的排列规则 
 * 4、判断问题是否满足多米诺性质
 * 5、确定每个分支的约束条件
 * 6、确定搜索策略：深度优先 or 广度优先 等
 * 7、确定存储值：一般存储搜索路径
 * 
 * 经典题：
 * 0、数字的全排列问题
 * 1、N皇后问题
 * 2、0-1背包
 * 3、货郎问题
 */

// 回溯递归模板
/*
    function rebacktrack(n){
        for let k=1 to n
            计算xk，sk // 赋予初值 
        reback(1)

        // 在第k层具体执行
        function reback(k){
            if(k>n) then <x1,x2,x3,....,xk>是解
            // k<n 那么需要对xk进行赋值
            else while(sk != null){// 当前的可供选择尚不为空
                xk =  sk 的最佳值(与不同的适用策略有关)
                sk = sk -{xk} // 从sk中剔除用过的xk
                计算下一层的sk+1 的取值范围是否有变化
                reback(k+1)
            }
        }
    }
*/