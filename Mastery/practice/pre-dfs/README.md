# 先序DFS

## 概念理解

- 如何理解先序的DFS？

  - 1.先序的意思意味着，从已知到未知，想象fib的执行过程，入栈函数dfs(1) dfs(3) dfs(4)
  - 2.深度优先的含义: 顺着已知线索，一直到细枝末节成为一条链。而BFS：则是浪花一排排的感觉(按层向下统计树深度)。宽度优先的扩展思维，依次将邻接节点放入队列决定next的访问顺序（邻接节点可根据扩展规则决定入队时机

- 如何理解访问顺序和邻接顺序

- 如何理解先序，中序，后序

- 先序DFS vs 先序For | 后序DFS

  - DFS先序的意义：DFS也可以像BFS一样做先序的拓扑排序
    先序BFS，先序DFS都需要统计入度，根据入度决定入队
    但一般做递推都是先用先序FOR，和后序DFS这种写法
    （因为一般入度是难以统计的

- fib这题涉及的数据结构：
  - | 抽象：逻辑结构 | 具体：存储结果    |
    | -------------- | ----------------- |
    | 线             | BFS队列，DFS栈    |
    | 树             | DFS后序不做记忆化 |
    | 图             | DFS后序记忆化     |
    | 集             | DP记忆化数组      |

## 练习

- 访问顺序：

  > 访问顺序仅将其视为一个序列即可：访问顺序的本质就是将任意数据结构值传递过程简化为线性结构去处理，故而对线性结构做顺序遍历的算法都可以应用到任意数据结构上去~

  - 先序

    - 1 144. 二叉树的前序遍历 | 2 589. N 叉树的前序遍历
      - 找到nextNode, dfs(nextNode)即可
    - 3 1600. 王位继承顺序

      -

      ```ts
      // 定义递归函数 Successor(x, curOrder) ，
      // 给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人
      Successor(x, curOrder):
        如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
          如果 x 是国王，那么返回 null
          否则，返回 Successor(x 的父亲, curOrder)
        否则，返回 x 不在 curOrder 中最年长的孩子
      ```

    - 4 114. 二叉树展开为链表

      - 顺序是明显的：先序的访问顺序
      - 递推在于:
        way1: 先序遍历访问顺序，在node时链接节点

        - prevNode.right = node.left; preNode.left = null;
        - preNode需要>0时链接, 同时注意leftNode的引用在递归之后会变化所以需要缓存

        way2：整体看待，左子树，右子树，不断左子树递归深入（先序）

        - 将左子树挂在node.right = node.left
        - 右子树断开连接的部分，不断入栈。（因为用的时候是后进先出的使用顺序

    - 5 652. 寻找重复的子树

      > 如果两棵树具有 相同的结构 和 相同的结点值 ，则认为二者是 重复 的。返回所有重复子树

      - way1: 找到每个节点出发的先序顺序，那么N^N => N^2时间复杂度，再数组里找相同的数组匹配。
      - way2: 使用编号代替子树的唯一结构，同时再使用三元组(root.val, lNode.num, rNode.num)序列化二叉树

        - 为子树设计唯一标识
        - 使用哈希表记录每个标识（子树）出现次数，当出现次数为 2（首次判定为重复出现）时，将该节点加入答案。

      - 【总结】

        - 怎么去记录已经找到的子结构
        - 以为找到的子结构必须找个地方存，没想到序列化+hash表
          - 而且找的子结构的过程，可以用递归做
          - 想到存hash，但是不知道怎么存啊，难道每个树都存一遍吗。。。
        - 充分利用了访问顺序的特点，当递归访问结束后，此时的node是子树的root
          - ---> map<hash(Tree), count>, 利用递归，当此时count=2时表示子结构相同的tree已开始重复出现了，所以赶紧push(node). 这个时候的node肯定也是另一个子树的root.val

        <del>
        way: 转换思路: 维护每个节点出发的扩散节点: gragh[x]= []
        或者，统计每个节点的前序节点。Map<node.val, []>
        </del>

  - 中序：注意中序只针对二叉树有讨论的意义，对于多叉树没有中序的说法~

    - 1 94. 二叉树的中序遍历
    - 2 501. 二叉搜索树中的众数

      > 二叉搜索树BST: 左 <= 根 <= 右。 求出现频率最高的数

      - way1: 遍历树节点，节点出现次数计数 Map<string, count>，最后找到最大值对应的key 时间度复杂度: 树遍历N+N
      - way2: 怎么利用上BST的属性特点？
        - BST的中序遍历是一个递增(or等于)的序列
        - 那么众数出现的地方，也是顺序出现的，在一个连续区间内
        - 问题就转换为有序数组遍历找众数的问题了
          - cur, maxCount, curCount,
            - 如果curCount > maxCount 则ans=[], ans.push(cur);
            - 如果curCount = maxCount, 证明出现了新众数, push(cur);

    - 3 897. 递增顺序搜索树：访问顺序的本质是视为链表处理
    - 4 538. 把二叉搜索树转换为累加树
      - BST中序遍历后，得到有序递增序列，基于这个有序递增进行累加
      - dp[x] = node[x] + dp[x-1]; // dp表示x节点的累加值 所以很明显是先序

- 后序

  - 1 145. 二叉树的后序遍历
  - 2 590. N 叉树的后序遍历

- 邻接顺序
  - 先序
    - 1 1469. 寻找所有的独生节点
    - 2 129. 求根节点到叶节点数字之和
    - 3 1430. 判断给定的序列是否是二叉树从根到叶的路径
    - 4 1372. 二叉树中的最长交错路径
    - 5 1457. 二叉树中的伪回文路径
    - 6 112. 路径总和
    - 7 113. 路径总和 II：
      - 回溯的本质是**先序\*邻接**传递的变量太大，需要通过全局变量或者引用变量进行回溯处理~
    - 8 1315. 祖父节点值为偶数的节点和
    - 9 1080. 根到叶路径上的不足节点
  - 后序
    1 1080. 根到叶路径上的不足节点 先序和后序的结合
