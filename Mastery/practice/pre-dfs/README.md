# 先序DFS

## 概念理解

- 如何理解先序的DFS？

  - 1.先序的意思意味着，从已知到未知，想象fib的执行过程，入栈函数dfs(1) dfs(3) dfs(4)
  - 2.深度优先的含义: 顺着已知线索，一直到细枝末节成为一条链。而BFS：则是浪花一排排的感觉(按层向下统计树深度)。宽度优先的扩展思维，依次将邻接节点放入队列决定next的访问顺序（邻接节点可根据扩展规则决定入队时机

- 如何理解访问顺序和邻接顺序

- 如何理解先序，中序，后序

- 先序DFS vs 先序For | 后序DFS

  - DFS先序的意义：DFS也可以像BFS一样做先序的拓扑排序
    先序BFS，先序DFS都需要统计入度，根据入度决定入队
    但一般做递推都是先用先序FOR，和后序DFS这种写法
    （因为一般入度是难以统计的

- fib这题涉及的数据结构：
  - | 抽象：逻辑结构 | 具体：存储结果    |
    | -------------- | ----------------- |
    | 线             | BFS队列，DFS栈    |
    | 树             | DFS后序不做记忆化 |
    | 图             | DFS后序记忆化     |
    | 集             | DP记忆化数组      |

## 练习

- 访问顺序：

  > 访问顺序仅将其视为一个序列即可：访问顺序的本质就是将任意数据结构值传递过程简化为线性结构去处理，故而对线性结构做顺序遍历的算法都可以应用到任意数据结构上去~

  - 先序

    - 1 144. 二叉树的前序遍历 | 2 589. N 叉树的前序遍历
      - 找到nextNode, dfs(nextNode)即可
    - 3 1600. 王位继承顺序

      -

      ```ts
      // 定义递归函数 Successor(x, curOrder) ，
      // 给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人
      Successor(x, curOrder):
        如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
          如果 x 是国王，那么返回 null
          否则，返回 Successor(x 的父亲, curOrder)
        否则，返回 x 不在 curOrder 中最年长的孩子
      ```

    - 4 114. 二叉树展开为链表

      - 递推在于:
        way1: 先序遍历访问顺序，在node时链接节点

        - prevNode.right = node.left; preNode.left = null;
        - preNode需要>0时链接, 同时注意leftNode的引用在递归之后会变化所以需要缓存

        way2：整体看待，左子树，右子树，不断左子树递归深入（先序）

        - 将左子树挂在node.right = node.left
        - 右子树断开连接的部分，不断入栈。（因为用的时候是后进先出的使用顺序

    - 5 652. 寻找重复的子树

  - 中序：注意中序只针对二叉树有讨论的意义，对于多叉树没有中序的说法~
    - 1 94. 二叉树的中序遍历
    - 2 501. 二叉搜索树中的众数
    - 3 897. 递增顺序搜索树：访问顺序的本质是视为链表处理
    - 4 538. 把二叉搜索树转换为累加树
  - 后序
    - 1 145. 二叉树的后序遍历
    - 2 590. N 叉树的后序遍历

- 邻接顺序
  - 先序
    - 1 1469. 寻找所有的独生节点
    - 2 129. 求根节点到叶节点数字之和
    - 3 1430. 判断给定的序列是否是二叉树从根到叶的路径
    - 4 1372. 二叉树中的最长交错路径
    - 5 1457. 二叉树中的伪回文路径
    - 6 112. 路径总和
    - 7 113. 路径总和 II：
      - 回溯的本质是**先序\*邻接**传递的变量太大，需要通过全局变量或者引用变量进行回溯处理~
    - 8 1315. 祖父节点值为偶数的节点和
    - 9 1080. 根到叶路径上的不足节点
  - 后序
    1 1080. 根到叶路径上的不足节点 先序和后序的结合
