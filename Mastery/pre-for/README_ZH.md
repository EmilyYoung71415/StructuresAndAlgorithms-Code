# for先序

写出对应的值传递三要素: 状态，递推，顺序

## 70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

这是关于选择的，这一梯 走or不走。就逐渐扩散出一棵树

状态: dp[x] 走x步，有多少种走法
递推:

<del>

```bash
  dp[0] = 0;
  dp[1] = 1;
  dp[2] = dp[x - 1] + 1 + (dp[x - 2] + 1); // 1+1 + 0+1 = 2
  ...
  dp[x] = dp[x - 1] + 1 + (dp[x - 2] + 2); // n=3; dp[2]+dp[1]+2 = 1+2+2

```

</del>

这是不对的。因为多算了
这两个不是相互独立的

<del>
尝试根据值的变化，画出了dag，知道了是求全部路径的问题。（即到达某个点的全部选择
然后参考公式就套出来了

```bash

dp[cur] = sum[dp[pre]]

```

</del>

最终看了下解析：递推式是`dp[]`

顺序: 先序\*邻接 针对dp for 即可

## 746.使用最小花费爬楼梯

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

请你计算并返回达到楼梯顶部的最低花费。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

```bash
e.g.

cost = [10,15,20], output: 15
cost = [1,100,1,1,1,100,1,1,100,1], output: 6

```

状态：到达x阶梯顶部，需要的最小花费 dp[x] = min(cost)
递推公式:

```
  从下标为0的台阶开始
  dp[0] 到达下标为0的台阶花费， 则0
  dp[1] 到达下标为1的台阶花费，也是0 // 因为出发点可以是0， 也可以是1
  dp[2] 到达下标为2的台阶花费：min(由0出发向上2步， or 由1出发向上1步)

// ❌注意边界值的理解
  // dp[0] = costs[0];
  // dp[1] = Math.min(costs[0], costs[1]);

// 每个dp[i]: i-2个节点直接跳2阶 or i-1节点跳1阶 or (i-2节点跳1阶，再跳1阶),
  dp[i] = min(dp[i-2] + cost[i-2],   dp[i-1]+cost[i-1], dp[i-2]+cost[i-1]+cost[i-2]);
  即dp[i] = min(dp[i-2] + cost[i-2],   dp[i-1]+cost[i-1]);
```

顺序：先序，for

## 1137.第N个泰波拉契数

泰波那契序列 Tn 定义如下：

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

```
  输入：n = 4
  输出：4
  解释：
    T_3 = 0 + 1 + 1 = 2
    T_4 = 1 + 1 + 2 = 4
```

这个应该比较简单，递推公式都给了
for先序
