/*****
 * 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格
 * 计算你所能获取的最大利润
 * leetcode:
 * [121]:最多只允许完成一笔交易（即买入和卖出一支股票）
 * 
 * [122]:可以尽可能地完成更多的交易（多次买卖一支股票）
 *     不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
 * 
 * [123]:最多可以完成 两笔 交易
 *     不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
 * 
 * [188]:最多可以完成 k 笔交易
 * 
 * [309]:买卖时间含有冷冻期 
 *     1.不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）
 *     2.卖出股票后,你无法在第二天买入股票 (即冷冻期为 1 天)
 * 
 * [714]:买卖含手续费
 *      购买了一个股票，在卖出它之前你就不能再继续购买股票了
 *      可以无限次地完成交易，但是你每次交易都需要付手续费
 * 
 */

/*****
 * 思路:
 * 抽象一个算法思维解决全部问题，dp
 * ==> [122~188] 最多可以完成k笔交易,而309,714都是dp下的约束条件
 * 188.最多k笔交易
 * 
 * exp:
 * [3,2,6,5,0,3], k = 2
 * 输出7 
 * 
 * 题目限制条件:
 * 1. 同时只能持有一支股票
 * ===> 当天要么持有股票 要么不持有股票。
 *      当天买入(没股票的前提下) or 卖出(有股票的前提下) 
 * 2. 最多k次交易次数
 * 
 * dp[i] 表示 到第i天 的最大利润
 * dp[i] = max{ dp[i-1] + a[i] // 卖出股票
 *              dp[i-1] - a[i] } // 买股票
 * // 但是不知道前一天是否有交易的资格，即卖出股票是否有股票
 * ==> dp[i][j] j={0,1} 表示 当前天是否持有股票
 * dp[i][j] ={
 *      dp[i][0] =  max{ dp[i-1][0] // 没有股票
 *                       dp[i-1][1] + a[i-1] }// 前一天有股票 卖出股票
 *      dp[i][1] =  max{ dp[i-1][0] - a[i-1] // 前一天没有股票 买入股票
 *                       dp[i-1][1] }             
 * }
 * 
 * 3. 但是呢，并不知道这次交易前交易过几次，是否满足不超过k次交易制约条件
 * dp[i][k][j]   k 表示当前天交易过多少次
 *  dp[i][k][0] = max{ dp[i-1][k][0] // 不动    
 *                     dp[i-1][k-1][1] + a[i]
 *                   }
 *  dp[i][k][1] = max{ dp[i-1][k-1][0] - a[i] 
 *                     dp[i-1][k][1]
 *                   }
 *   
 * 最后的结果值肯定在 max{dp[n-1][{0,...k}],0}里最后股票肯定是会被卖出去的
 */

// 123 最多交易两次
/***
 * dp[i][k][j]  
 *      j = {0,1}
 *      k = {0,1,2}
 * exp:
 *  Input: [3,3,5,0,0,3,1,4]
    Output: 6
 * 
 * 
 */
// console.log(maxProfit( [3,3,5,0,0,3,1,4]))
function maxProfit1(prices){
    if(prices.length<1) return 0;
    let dp = [],
        n = prices.length;
    
    // 生成一个三维数组
    for(let i=0;i<=n;i++){
        dp[i] = [];
        for(let j=0;j<=2;j++){
            dp[i][j] = []; 
        }
    }

    // 初始化 到第0天的最大利润
    dp[0][0][0] = 0,dp[0][0][1] = -prices[0];
    dp[0][1][0] = dp[0][1][1] = dp[0][2][0] = dp[0][2][0] = -Infinity;
    
    for(let i=1;i<=n;i++){
        // 交易0次
        dp[i][0][0] =  dp[i-1][0][0];
        dp[i][0][1] = Math.max(dp[i-1][0][1],dp[i-1][0][0]-prices[i]);

        dp[i][1][0] = Math.max(dp[i-1][1][0],dp[i-1][0][1]+prices[i]);
        dp[i][1][1] = Math.max(dp[i-1][1][1],dp[i-1][1][0]-prices[i]);

        dp[i][2][0] = Math.max(dp[i-1][2][0],dp[i-1][1][1]+prices[i]);
    }
    return Math.max(dp[n-1][0][0],dp[n-1][1][0],dp[n-1][2][0])
}

/****
 * leetcode:121 最多买一次
 * dp[i][j] j={0,1,2} 0：还没买股票。1：买入了一股股票还没卖 2.之前买了一股股票现在把他卖了
 * 
 * exp；
 *  Input: [7,1,5,3,6,4]
    Output: 5
 */
console.log(maxProfit( [7,1,5,3,6,4]))
function maxProfit(prices){
    if(prices==null || prices.length<1) return 0;

    let dp = [],n = prices.length;
    for(let i=0;i<n;i++){
        dp[i] = [];
    }

    // 初始值
    dp[0][0] = 0,dp[0][1] = -prices[0],dp[0][2] = 0;

    let result = 0;
    for(let i=1;i<n;i++){
        dp[i][0] = dp[i-1][0];
        dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        dp[i][2] = dp[i-1][1] + prices[i];
        result = Math.max(result,dp[i][0],dp[i][1],dp[i][2]);
    }
    return result;
}

